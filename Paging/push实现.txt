一，Provider是指某个iPhone软件的Push服务器。APNS 是Apple Push Notification Service（Apple Push服务器）的缩写，是苹果的服务器。
第一阶段：Provider把要发送的消息、目的iPhone的标识打包，发给APNS。 
第二阶段：APNS在自身的已注册Push服务的iPhone列表中，查找有相应标识的iPhone，并把消息发到iPhone。 
第三阶段：iPhone把发来的消息传递给相应的应用程序， 并且按照设定弹出Push通知。

无论是iPhone客户端跟APNS,还是Provider和APNS都需要通过证书进行连接的
deviceToken是iphone的设备令牌，每个iphone独有。

证书生成（略）可参考http://blog.csdn.net/zhuqilin0/article/details/6527113

具体实现：
我们在程序中获取到了手机的deviceToke，?获取到的deviceToken，我们可以通过webservice服务提交给服务器Provider，provider服务器再将要发送的消息（这里指要推送的消息）发送给APNS（苹果服务器）。
这里需要一个与APNS连接的证书，APNS再将消息发送给目的iphone。

二，创建一个iPhone应用程序

在delegate.m中添加如下方法
//通过registerForRemoteNotificationTypes方法，告诉应用程序，能接受push来的通知
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions
{
    [[UIApplication sharedApplication]registerForRemoteNotificationTypes:(UIRemoteNotificationTypeBadge | UIRemoteNotificationTypeSound | UIRemoteNotificationTypeAlert)];
    [[UIApplication sharedApplication] setApplicationIconBadgeNumber:0];
    
    // Add the view controller’s view to the window and display. 
    [self.window addSubview:viewController.view]; 
    [self.window makeKeyAndVisible];
    return YES;
}

//添加下面方法获取deviceToken 
-(void)application:(UIApplication*)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken
{
    NSLog(@"My token is %@",deviceToken);
}

-(void)application:(UIApplication*)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error
{
    NSLog(@"Failed to get token,error: %@",error);
}
-(void)application:(UIApplication*)application didReceiveRemoteNotification:(NSDictionary *)userInfo {
    
    NSLog(@" 收到推送消息 ： %@",[[userInfo objectForKey:@"aps"] objectForKey:@"alert"]);
    if ([[userInfo objectForKey:@"aps"] objectForKey:@"alert"]!=NULL) {
        UIAlertView* alert = [[UIAlertView alloc] initWithTitle:@"推送通知"
                                                        message:[[userInfo objectForKey:@"aps"] objectForKey:@"alert"]
                                                       delegate:self
                                              cancelButtonTitle:@" 关闭"
                                              otherButtonTitles:@" 更新状态",nil];
        [alert show];
        [alert release];
    }
    
}


//这里要注意：这个程序只能在设备上运行，在模拟器上得不到deviceToken。在设备上运行后，在Consle中会打印出一段字符串。这里一shenYF这部iphone手机为例。得到的是 <f3366a4c 3df8ec49 d334bfe6 8deb9350 68776a26 aad665a1 3e5e3650 588dcf5c>

三.现在处理push服务器。这里使用PushMeBaby这个现有的程序。

- (id)init {
	self = [super init];
    
	if(self != nil) {
        
		self.deviceToken = @"f3366a4c 3df8ec49 d334bfe6 8deb9350 68776a26 aad665a1 3e5e3650 588dcf5c";
		self.payload = @"{\"aps\":{\"alert\":\"This is some fancy message.\",\"badge\":1}}";
		self.certificate = [[NSBundle mainBundle] pathForResource:@"aps_developer.identity" ofType:@"cer"];
         
	}
    
	return self;
}

将deviceToken填写成设备的token字符串，这里用的是刚得到的那个。将pathForResource后面那个改成刚下载的证书名。另外，将刚下载的证书导入到PushMeBaby的Resources目录下。运行即可。

注：
苹果提供两种接入方式的证书：

developer，用于测试
production，用于产品



